var D=new Function("try {return this===window;}catch(e){ return false;}");var j=globalThis.performance&&globalThis.performance.now,_=j?performance.now():Date.now();globalThis.crossOriginIsolated||console.warn(`[@ircam/sc-gettime] Your page is not Cross Origin Isolated. The accuracy of the clock may be reduced by the User-Agent to prevent finger-printing
(see: https://web.dev/coop-coep/ for more informations)`);function p(s){return Object.prototype.toString.call(s)=="[object Function]"||Object.prototype.toString.call(s)=="[object AsyncFunction]"}function f(s){return Number(s)===s}function a(s,t=1e-9){return Math.round(s/t)*t}function x(s){return JSON.parse(JSON.stringify(s))}var P=s=>s;function h(s){return Number.isFinite(s)&&s>=0}function S(s,t,e){let i=s[t];s[t]=s[e],s[e]=i}var c=Symbol("sc-scheduling:queue-time"),m=Symbol("sc-scheduling:queue-priority"),v=class{#e=1;#t=null;constructor(t=1e3){this.#t=new Array(t+1)}get time(){return this.#e>1?this.#t[1][c]:1/0}get head(){return this.#t[1]}#i(t,e){let i=t[c],o=e[c];if(i===o){let n=t[m],r=e[m];return n<r}return i>o}#o(t,e){let i=t[c],o=e[c];if(i===o){let n=t[m],r=e[m];return n>r}return i<o}#s(t){let e=this.#t[t],i=t,o=Math.floor(i/2),n=this.#t[o];for(;n&&this.#o(e,n);)S(this.#t,i,o),i=o,o=Math.floor(i/2),n=this.#t[o]}#r(t){let e=this.#t[t],i=t,o=i*2,n=o+1,r=this.#t[o],u=this.#t[n];for(;r&&this.#i(e,r)||u&&this.#i(e,u);){let d;u?d=this.#o(r,u)?o:n:d=o,S(this.#t,i,d),i=d,o=i*2,n=o+1,r=this.#t[o],u=this.#t[n]}}#u(){let t=Math.floor((this.#e-1)/2);for(let e=t;e>0;e--)this.#r(e)}#n(t){return Number.isFinite(t)?t=a(t):(Math.abs(t)!==1/0&&console.warn(`PriorityQueue: time is not a number: "${t}" (overriden to Infinity). This probably shows an error in your implementation.`),t=this.reverse?-1/0:1/0),t}add(t,e,i=0){return e=this.#n(e),t[c]=e,t[m]=i,this.#t[this.#e]=t,this.#s(this.#e),this.#e+=1,this.time}move(t,e){let i=this.#t.indexOf(t);if(i!==-1){t[c]=this.#n(e);let o=this.#t[Math.floor(i/2)];o&&this.#o(t,o)?this.#s(i):this.#r(i)}return this.time}remove(t){let e=this.#t.indexOf(t);if(e!==-1){let i=this.#e-1;if(e===i)this.#t[i]=void 0;else if(S(this.#t,e,i),this.#t[i]=void 0,e===1)this.#r(1);else{let o=this.#t[e],n=this.#t[Math.floor(e/2)];n&&this.#o(o,n)?this.#s(e):this.#r(e)}delete t[c],delete t[m],this.#e=i}return this.time}clear(){for(let t=1;t<this.#e;t++)delete this.#t[t][c],delete this.#t[t][m];this.#e=1,this.#t=new Array(this.#t.length)}has(t){return this.#t.includes(t)}},A=v;var z=Symbol.for("nodejs.util.inspect.custom"),y=Symbol("sc-scheduling:tick-lookahead"),b=class{constructor(){this[y]=0}get tickLookahead(){return this[y]}[z](){return`SchedulerEvent { tickLookahead: ${this.tickLookahead} }`}};var T=Symbol("sc-scheduling:scheduler"),l=Symbol("sc-scheduling:compat-mode"),k=class{#e=null;#t=null;#i=null;#o=null;#s=null;#r=null;#u=new b;#n=null;#a=new Set;#m=null;#l=1/0;#d=null;#h=new Map;constructor(t,{period:e=.02,lookahead:i=.05,queueSize:o=1e3,currentTimeToProcessorTimeFunction:n=P,currentTimeToAudioTimeFunction:r=null,maxRecursions:u=100,verbose:d=!1}={}){if(!p(t))throw new TypeError("Cannot construct 'Scheduler': argument 1 should be a function returning a time in seconds");if(!Number.isFinite(e)||e<=0)throw new RangeError(`Cannot construct 'Scheduler': option 'period' (${e}) must be a strictly positive number`);if(!Number.isFinite(i)||i<=0)throw new RangeError(`Cannot construct 'Scheduler': option 'lookahead' (${i}) must be a strictly positive number`);if(i<=e)throw new RangeError(`Cannot construct 'Scheduler': option 'lookahead' (${i}) be greater than period (${e})`);if(!Number.isFinite(o)||o<=0)throw new RangeError(`Cannot construct 'Scheduler': option 'queueSize' (${o}) must be a strictly positive number`);if(!Number.isFinite(u)||u<=0)throw new RangeError(`Cannot construct 'Scheduler': option 'maxRecursions' (${u}) must be a strictly positive number`);if(r!==null&&(console.warn("[Scheduler] 'options.currentTimeToAudioTimeFunction' is deprecated and will be removed in next release, use 'options.currentTimeToProcessorTimeFunction' instead."),n=r),!p(n))throw new TypeError("Cannot construct 'Scheduler': option 'currentTimeToProcessorTimeFunction' should be a function");this.#n=new A(o),this.#e=t,this.#t=e,this.#i=i,this.#o=n,this.#s=u,this.#r=!!d,this.#m=this.#f.bind(this)}get period(){return this.#t}set period(t){if(!Number.isFinite(t)||t<=0||t>=this.lookahead)throw new RangeError("Cannot set 'period' on Scheduler: value must be strictly positive and lower than lookahead");this.#t=t}get lookahead(){return this.#i}set lookahead(t){if(!Number.isFinite(t)||t<=0||t<=this.period)throw new RangeError("Cannot set 'lookahead' on Scheduler: value must be strictly positive and greater than period");this.#i=t}get currentTime(){return this.#e()}get audioTime(){return console.warn("[Scheduler] 'audioTime' getter is deprecated and will be removed in next release, use 'processorTime' instead."),this.#o(this.currentTime)}get processorTime(){return this.#o(this.currentTime)}defer(t,e){let i=(o,n,r)=>(setTimeout(()=>{let u=this.#e();r[y]=o-u,t(o,n,r)},Math.ceil(r.tickLookahead*1e3)),null);this.add(i,e)}has(t){return t[l]&&(t=t[l]),this.#a.has(t)}add(t,e=this.currentTime,i=0){if(p(t.advanceTime)&&(t[l]===void 0&&(t[l]=t.advanceTime.bind(t)),t=t[l]),!p(t))throw new TypeError("Cannot execute 'add' on Scheduler: argument 1 is not a function");if(t[T]!==void 0)throw t[T]!==this?new DOMException("Cannot execute 'add' on Scheduler: Processor belongs to another scheduler","NotSupportedErrror"):new DOMException("Cannot execute 'add' on Scheduler: Processor has already been added to this scheduler","NotSupportedErrror");t[T]=this,this.#a.add(t),this.#h.set(t,{time:null,counter:0}),this.#n.add(t,e,i);let o=this.#n.time;this.#c(o,!0)}reset(t,e=void 0){if(t[l]&&(t=t[l]),!this.has(t))throw new DOMException("Cannot execute 'reset' on Scheduler: Processor has not been added to this scheduler","NotSupportedError");if(f(e)){let o=this.#h.get(t);o.time=e,o.counter=1,this.#n.move(t,e)}else this.#p(t);let i=this.#n.time;this.#c(i,!0)}remove(t){if(t[l]&&(t=t[l]),!this.has(t))throw new DOMException("Cannot execute 'reset' on Scheduler: Processor has not been added to this scheduler","NotSupportedError");this.#p(t);let e=this.#n.time;this.#c(e,!0)}clear(){for(let t of this.#a)delete t[T];this.#n.clear(),this.#a.clear(),this.#h.clear(),this.#c(1/0,!1)}#p(t){delete t[T],this.#n.remove(t),this.#a.delete(t),this.#h.delete(t)}#f(){let t=this.#e(),e=this.#n.time;for(this.#d=null;e<=t+this.lookahead;){let i=this.#n.head,o=this.#h.get(i);this.#u[y]=e-t;let n=this.#o(e),r;try{r=i(e,n,this.#u)}catch(u){console.warn("Running processor threw an error, processor removed from scheduler"),console.log(u),this.#p(i)}r===o.time?(o.counter+=1,o.counter>=this.#s&&(console.warn(`[Scheduler] maxRecursions (${this.#s}) at the same time (${r}) has been reached, processor discarded:
${i}
This is generally due to a implementation bug, but if you know what you are doing you should consider increasing the 'maxRecursions' option.`),r=1/0)):(o.time=r,o.counter=1),f(r)?this.#n.move(i,r):this.#p(i),e=this.#n.time}this.#c(e,!1)}#c(t,e){let i=this.#l;if(this.#l=t,clearTimeout(this.#d),this.#l!==1/0){this.#r&&i===1/0&&console.log("[Scheduler] > scheduler start");let o=this.#e(),n=this.#l-o,r=e?.001:this.period,u=Math.max(n-this.lookahead,r);this.#d=setTimeout(this.#m,Math.ceil(u*1e3))}else this.#r&&i!==1/0&&console.log("[Scheduler] > scheduler stop")}},C=k;var B=Symbol.for("nodejs.util.inspect.custom"),I=class{#e=null;#t=null;#i=null;#o=null;#s=null;#r=null;#u=null;#n=null;constructor(t,e){this.#e=t.eventType,this.#t=t.time,this.#i=t.position,this.#o=t.speed,this.#s=t.loop,this.#r=t.loopStart,this.#u=t.loopEnd,this.#n=e}get type(){return this.#e}get time(){return this.#t}get position(){return this.#i}get speed(){return this.#o}get loop(){return this.#s}get loopStart(){return this.#r}get loopEnd(){return this.#u}get tickLookahead(){return this.#n}[B](){return`TransportEvent {
  type: '${this.type}',
  time: ${this.time}
  position: ${this.position}
  speed: ${this.speed}
  loop: ${this.loop}
  loopStart: ${this.loopStart}
  loopEnd: ${this.loopEnd}
  tickLookahead: ${this.tickLookahead}
}    `}},g=I;var w=class{constructor(t){if(!Number.isFinite(t))throw new TypeError("Cannot construct 'TransportEventQueue': argument 1 should be the current time at instanciation");this.state={eventType:null,time:t,position:0,speed:0,loop:!1,loopStart:0,loopEnd:1/0},this.previousState=null,this.scheduledEvents=[],this.speed=1}get next(){return this.scheduledEvents[0]||null}add(t){if(!["start","stop","pause","seek","cancel","loop","loop-start","loop-end","loop-point","speed"].includes(t.type))throw new Error(`Invalid event type: "${t.type}"`);if(this.state.time>t.time)return console.error("Cannot execute 'add' on TransportEventQueue: Given 'event.time' is before current 'state.time'. Aborting...",t),null;if(t.type==="cancel")return this.scheduledEvents=this.scheduledEvents.filter(i=>i.time<t.time),t;this.scheduledEvents.push(t),this.scheduledEvents.sort((i,o)=>{if(i.time<o.time)return-1;if(i.time>o.time)return 1;if(i.time===o.time)return 0});let e=this.state.eventType;return this.scheduledEvents=this.scheduledEvents.filter((i,o)=>["start","stop","pause","cancel"].includes(i.type)?i.type!==e?(e=i.type,!0):!1:!0),this.scheduledEvents.indexOf(t)!==-1?t:null}dequeue(){let t=this.next,e=Object.assign({},this.state);switch(e.eventType=t.type,e.time=t.time,e.position=this.getPositionAtTime(t.time),t.type){case"start":e.speed=this.speed;break;case"stop":e.position=0,e.speed=0;break;case"pause":e.speed=0;break;case"seek":e.position=t.position;break;case"loop":e.loop=t.loop;break;case"loop-start":e.loopStart=t.loopStart;break;case"loop-end":e.loopEnd=t.loopEnd;break;case"loop-point":e.position=t.position;break;case"speed":this.speed=t.speed,e.speed>0&&(e.speed=t.speed);break}if(this.scheduledEvents.shift(),this.state=e,this.scheduledEvents=this.scheduledEvents.filter(i=>i.type!=="loop-point"),this.state.loop&&this.state.speed>0&&this.state.position<this.state.loopEnd){let i={type:"loop-point",time:this.getTimeAtPosition(this.state.loopEnd),position:this.state.loopStart};this.add(i)}return Object.assign({},this.state)}getPositionAtTime(t){if(!Number.isFinite(t))return 1/0;let e=this.state,i=e.position+(t-e.time)*e.speed,o=e.position;if(e.loop&&i>=e.loopEnd){i=i-e.loopStart;let n=i%(e.loopEnd-e.loopStart);i=e.loopStart+n,e.time=t-n,e.position=e.loopStart,o=Math.min(e.position,e.loopStart)}return Math.max(i,o)}getTimeAtPosition(t){return Number.isFinite(t)?this.state.speed===0?this.state.time:this.state.time+(t-this.state.position)/this.state.speed:1/0}};var E=Symbol("sc-scheduling:transport"),N=class{#e=null;#t=null;#i=null;#o=new Map;#s=1e3;constructor(t,e=null){if(!(t instanceof C))throw new TypeError("Cannot construct 'Transport': Argument 1 must be an instance of Scheduler");this.#e=t,this.#i=new w(this.#e.currentTime),this.#t=this.#r.bind(this),e!==null&&(this.#i.state=e.currentState,this.addEvents(e.scheduledEvents))}serialize(){return{currentState:x(this.#i.state),scheduledEvents:x(this.#i.scheduledEvents)}}get scheduler(){return this.#e}get currentTime(){return this.#e.currentTime}get processorTime(){return this.#e.processorTime}get currentPosition(){return this.getPositionAtTime(this.currentTime)}getPositionAtTime(t){return a(this.#i.getPositionAtTime(t))}start(t=this.currentTime){if(!h(t))throw new TypeError("Cannot execute 'start' on 'Transport': argument 1 (time) should be a positive number");let e={type:"start",time:a(t)};return this.addEvent(e)}stop(t=this.currentTime){if(!h(t))throw new TypeError("Cannot execute 'stop' on 'Transport': argument 1 (time) should be a positive number");let e={type:"stop",time:a(t)};return this.addEvent(e)}pause(t=this.currentTime){if(!h(t))throw new TypeError("Cannot execute 'pause' on 'Transport': argument 1 (time) should be a positive number");let e={type:"pause",time:a(t)};return this.addEvent(e)}seek(t,e=this.currentTime){if(!Number.isFinite(t))throw new TypeError("Cannot execute 'seek' on 'Transport': argument 1 (position) should be a finite number");if(!h(e))throw new TypeError("Cannot execute 'seek' on 'Transport': argument 2 (time) should be a positive number");let i={type:"seek",time:a(e),position:t};return this.addEvent(i)}loop(t,e=this.currentTime){if(typeof t!="boolean")throw new TypeError("Cannot execute 'loop' on 'Transport': argument 2 (value) should be a boolean");if(!h(e))throw new TypeError("Cannot execute 'loop' on 'Transport': argument 1 (time) should be a positive number");let i={type:"loop",time:a(e),loop:t};return this.addEvent(i)}loopStart(t,e=this.currentTime){if(t!==-1/0&&!Number.isFinite(t))throw new TypeError("Cannot execute 'loopStart' on 'Transport': argument 1 (position) should be either a finite number or -Infinity");if(!h(e))throw new TypeError("Cannot execute 'loopStart' on 'Transport': argument 2 (time) should be a positive number");let i={type:"loop-start",time:a(e),loopStart:t};return this.addEvent(i)}loopEnd(t,e=this.currentTime){if(t!==1/0&&!Number.isFinite(t))throw new TypeError("Cannot execute 'loopStart' on 'Transport': argument 1 (position) should be either a finite number or Infinity");if(!h(e))throw new TypeError("Cannot execute 'loopEnd' on 'Transport': argument 2 (time) should be a positive number");let i={type:"loop-end",time:a(e),loopEnd:t};return this.addEvent(i)}speed(t,e=this.currentTime){if(!Number.isFinite(t))throw new TypeError("Cannot execute 'speed' on 'Transport': argument 1 (value) should be a positive number");if(!h(e))throw new TypeError("Cannot execute 'speed' on 'Transport': argument 2 (time) should be a positive number");let i={type:"speed",time:a(e),speed:t};return this.addEvent(i)}cancel(t=this.currentTime){if(!h(t))throw new TypeError("Cannot execute 'cancel' on 'Transport': argument 1 (time) should be a positive number");let e={type:"cancel",time:a(t)};return this.addEvent(e)}addEvent(t){if(t===null)return null;let e=this.#i.next,i=this.#i.add(t);return i!==null&&i.type!=="cancel"&&(this.#e.has(this.#t)?(!e||i.time<e.time)&&this.#e.reset(this.#t,i.time):this.#e.add(this.#t,this.#i.next.time,this.#s)),i}addEvents(t){return t.map(e=>this.addEvent(e))}add(t){if(!p(t))throw new TypeError("Cannot execute 'add' on 'Transport': argument 1 is not a function");if(t[E]!==void 0)throw t[E]!==this?new DOMException("Cannot execute 'add' on 'Transport': processor already added to another transport","NotSupportedError"):new DOMException("Cannot execute 'add' on 'Transport': processor already added this transport","NotSupportedError");t[E]=this;let e=function(F,O,$){let L=this.getPositionAtTime(F),M=t(L,O,$);return f(M)?this.#i.getTimeAtPosition(M):1/0}.bind(this);this.#o.set(t,e);let i=this.currentTime,o=this.processorTime,n=x(this.#i.state);n.eventType="init";let r=n.time-i,u=new g(n,r);this.#e.add(e,1/0),this.#u(e,i,o,u)}has(t){return this.#o.has(t)}remove(t){if(!this.has(t))throw new DOMException("Cannot execute 'remove' on 'Transport': processor does not belong to this transport","NotSupportedError");let e=this.#o.get(t);this.#e.remove(e),this.#o.delete(t),delete t[E]}clear(){for(let t of this.#o.keys())this.remove(t);this.cancel(this.currentTime),this.stop(this.currentTime)}#r(t,e,i){let o=this.#i.dequeue(),n=new g(o,i.tickLookahead);for(let r of this.#o.values())this.#u(r,t,e,n);return this.#i.next?this.#i.next.time:1/0}#u(t,e,i,o){let n;try{n=t(e,i,o)}catch(r){console.error(r)}this.#e.reset(t,n)}},Q=N;export{C as Scheduler,b as SchedulerEvent,Q as Transport,g as TransportEvent};
